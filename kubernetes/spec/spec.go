// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package spec

import "encoding/json"
import "fmt"
import "reflect"

// Defines an authentication policy.
type AuthenticationPolicy map[string]interface{}

// Defines the call to perform.
type CallTask interface{}

type Duration interface{}

// Represents an endpoint.
type Endpoint interface{}

// Represents an error.
type Error struct {
	// A human-readable explanation specific to this occurrence of the error.
	Detail *string `json:"detail,omitempty"`

	// A JSON Pointer used to reference the component the error originates from.
	Instance interface{} `json:"instance,omitempty"`

	// The status code generated by the origin for this occurrence of the error.
	Status int `json:"status"`

	// A short, human-readable summary of the error.
	Title *string `json:"title,omitempty"`

	// A URI reference that identifies the error type.
	Type interface{} `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Error) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["status"]; raw != nil && !ok {
		return fmt.Errorf("field status in Error: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Error: required")
	}
	type Plain Error
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Error(plain)
	return nil
}

// Describe the event consumption strategy to adopt.
type EventConsumptionStrategy map[string]interface{}

// An event filter is a mechanism used to selectively process or handle events
// based on predefined criteria, such as event type, source, or specific
// attributes.
type EventFilter struct {
	// A correlation is a link between events and data, established by mapping event
	// attributes to specific data attributes, allowing for coordinated processing or
	// handling based on event characteristics.
	Correlate EventFilterCorrelate `json:"correlate,omitempty"`

	// An event filter is a mechanism used to selectively process or handle events
	// based on predefined criteria, such as event type, source, or specific
	// attributes.
	With EventProperties `json:"with"`
}

// A correlation is a link between events and data, established by mapping event
// attributes to specific data attributes, allowing for coordinated processing or
// handling based on event characteristics.
type EventFilterCorrelate map[string]struct {
	// A constant or a runtime expression, if any, used to determine whether or not
	// the extracted correlation value matches expectations. If not set, the first
	// extracted value will be used as the correlation's expectation.
	Expect *string `json:"expect,omitempty"`

	// A runtime expression used to extract the correlation value from the filtered
	// event.
	From string `json:"from"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventFilter) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["with"]; raw != nil && !ok {
		return fmt.Errorf("field with in EventFilter: required")
	}
	type Plain EventFilter
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EventFilter(plain)
	return nil
}

// Describes the properties of an event.
type EventProperties struct {
	// Content type of data value. This attribute enables data to carry any type of
	// content, whereby format and encoding might differ from that of the chosen event
	// format.
	Datacontenttype *string `json:"datacontenttype,omitempty"`

	// The schema describing the event format.
	Dataschema interface{} `json:"dataschema,omitempty"`

	// The event's unique identifier.
	Id *string `json:"id,omitempty"`

	// Identifies the context in which an event happened.
	Source interface{} `json:"source,omitempty"`

	// The subject of the event.
	Subject *string `json:"subject,omitempty"`

	// When the event occured.
	Time interface{} `json:"time,omitempty"`

	// This attribute contains a value describing the type of event related to the
	// originating occurrence.
	Type *string `json:"type,omitempty"`

	AdditionalProperties interface{}
}

// Set the content of the context. .
type Export struct {
	// A runtime expression, if any, used to export the output data to the context.
	As interface{} `json:"as,omitempty"`

	// The schema used to describe and validate the workflow context.
	Schema *Schema `json:"schema,omitempty"`
}

// The definition of an extension.
type Extension struct {
	// The task(s) to execute after the extended task, if any.
	After TaskList `json:"after,omitempty"`

	// The task(s) to execute before the extended task, if any.
	Before TaskList `json:"before,omitempty"`

	// The type of task to extend.
	Extend ExtensionExtend `json:"extend"`

	// A runtime expression, if any, used to determine whether or not the extension
	// should apply in the specified context.
	When *string `json:"when,omitempty"`
}

type ExtensionExtend string

const ExtensionExtendAll ExtensionExtend = "all"
const ExtensionExtendCall ExtensionExtend = "call"
const ExtensionExtendComposite ExtensionExtend = "composite"
const ExtensionExtendEmit ExtensionExtend = "emit"
const ExtensionExtendFor ExtensionExtend = "for"
const ExtensionExtendListen ExtensionExtend = "listen"
const ExtensionExtendRaise ExtensionExtend = "raise"
const ExtensionExtendRun ExtensionExtend = "run"
const ExtensionExtendSet ExtensionExtend = "set"
const ExtensionExtendSwitch ExtensionExtend = "switch"
const ExtensionExtendTry ExtensionExtend = "try"
const ExtensionExtendWait ExtensionExtend = "wait"

var enumValues_ExtensionExtend = []interface{}{
	"call",
	"composite",
	"emit",
	"for",
	"listen",
	"raise",
	"run",
	"set",
	"switch",
	"try",
	"wait",
	"all",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExtensionExtend) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExtensionExtend {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExtensionExtend, v)
	}
	*j = ExtensionExtend(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Extension) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["extend"]; raw != nil && !ok {
		return fmt.Errorf("field extend in Extension: required")
	}
	type Plain Extension
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Extension(plain)
	return nil
}

// Represents an external resource.
type ExternalResource struct {
	// The endpoint of the external resource.
	Endpoint ExternalResourceEndpoint `json:"endpoint"`

	// The name of the external resource, if any.
	Name *string `json:"name,omitempty"`
}

// The endpoint of the external resource.
type ExternalResourceEndpoint interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExternalResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["endpoint"]; raw != nil && !ok {
		return fmt.Errorf("field endpoint in ExternalResource: required")
	}
	type Plain ExternalResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExternalResource(plain)
	return nil
}

// Represents different transition options for a workflow.
type FlowDirective interface{}

// Configures the input of a workflow or task.
type Input struct {
	// A runtime expression, if any, used to mutate and/or filter the input of the
	// workflow or task.
	From interface{} `json:"from,omitempty"`

	// The schema used to describe and validate the input of the workflow or task.
	Schema *Schema `json:"schema,omitempty"`
}

// Inline configuration of the OAuth2 authentication policy.
type Oauth2AuthenticationProperties struct {
	// The security token that represents the identity of the acting party.
	Actor *Oauth2Token `json:"actor,omitempty"`

	// The audiences, if any, to request the token for.
	Audiences []string `json:"audiences,omitempty"`

	// The URI that references the OAuth2 authority to use.
	Authority *string `json:"authority,omitempty"`

	// The definition of an OAuth2 client.
	Client *Oauth2AuthenticationPropertiesClient `json:"client,omitempty"`

	// The grant type to use.
	Grant *Oauth2AuthenticationPropertiesGrant `json:"grant,omitempty"`

	// A list that contains that contains valid issuers that will be used to check
	// against the issuer of generated tokens.
	Issuers []string `json:"issuers,omitempty"`

	// The password to use. Used only if the grant type is Password.
	Password *string `json:"password,omitempty"`

	// The configuration of an OAuth2 token request
	Request *Oauth2AuthenticationPropertiesRequest `json:"request,omitempty"`

	// The scopes, if any, to request the token for.
	Scopes []string `json:"scopes,omitempty"`

	// The security token that represents the identity of the party on behalf of whom
	// the request is being made.
	Subject *Oauth2Token `json:"subject,omitempty"`

	// The username to use. Used only if the grant type is Password.
	Username *string `json:"username,omitempty"`
}

// The definition of an OAuth2 client.
type Oauth2AuthenticationPropertiesClient struct {
	// A JWT containing a signed assertion with your application credentials.
	Assertion *string `json:"assertion,omitempty"`

	// The authentication method to use to authenticate the client.
	Authentication Oauth2AuthenticationPropertiesClientAuthentication `json:"authentication,omitempty"`

	// The client id to use.
	Id *string `json:"id,omitempty"`

	// The client secret to use, if any.
	Secret *string `json:"secret,omitempty"`
}

type Oauth2AuthenticationPropertiesClientAuthentication string

const Oauth2AuthenticationPropertiesClientAuthenticationClientSecretBasic Oauth2AuthenticationPropertiesClientAuthentication = "client_secret_basic"
const Oauth2AuthenticationPropertiesClientAuthenticationClientSecretJwt Oauth2AuthenticationPropertiesClientAuthentication = "client_secret_jwt"
const Oauth2AuthenticationPropertiesClientAuthenticationClientSecretPost Oauth2AuthenticationPropertiesClientAuthentication = "client_secret_post"
const Oauth2AuthenticationPropertiesClientAuthenticationNone Oauth2AuthenticationPropertiesClientAuthentication = "none"
const Oauth2AuthenticationPropertiesClientAuthenticationPrivateKeyJwt Oauth2AuthenticationPropertiesClientAuthentication = "private_key_jwt"

var enumValues_Oauth2AuthenticationPropertiesClientAuthentication = []interface{}{
	"client_secret_basic",
	"client_secret_post",
	"client_secret_jwt",
	"private_key_jwt",
	"none",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Oauth2AuthenticationPropertiesClientAuthentication) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Oauth2AuthenticationPropertiesClientAuthentication {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Oauth2AuthenticationPropertiesClientAuthentication, v)
	}
	*j = Oauth2AuthenticationPropertiesClientAuthentication(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Oauth2AuthenticationPropertiesClient) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Oauth2AuthenticationPropertiesClient
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["authentication"]; !ok || v == nil {
		plain.Authentication = "client_secret_post"
	}
	*j = Oauth2AuthenticationPropertiesClient(plain)
	return nil
}

type Oauth2AuthenticationPropertiesGrant string

const Oauth2AuthenticationPropertiesGrantAuthorizationCode Oauth2AuthenticationPropertiesGrant = "authorization_code"
const Oauth2AuthenticationPropertiesGrantClientCredentials Oauth2AuthenticationPropertiesGrant = "client_credentials"
const Oauth2AuthenticationPropertiesGrantPassword Oauth2AuthenticationPropertiesGrant = "password"
const Oauth2AuthenticationPropertiesGrantRefreshToken Oauth2AuthenticationPropertiesGrant = "refresh_token"
const Oauth2AuthenticationPropertiesGrantUrnIetfParamsOauthGrantTypeTokenExchange Oauth2AuthenticationPropertiesGrant = "urn:ietf:params:oauth:grant-type:token-exchange"

var enumValues_Oauth2AuthenticationPropertiesGrant = []interface{}{
	"authorization_code",
	"client_credentials",
	"password",
	"refresh_token",
	"urn:ietf:params:oauth:grant-type:token-exchange",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Oauth2AuthenticationPropertiesGrant) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Oauth2AuthenticationPropertiesGrant {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Oauth2AuthenticationPropertiesGrant, v)
	}
	*j = Oauth2AuthenticationPropertiesGrant(v)
	return nil
}

// The configuration of an OAuth2 token request
type Oauth2AuthenticationPropertiesRequest struct {
	// Encoding corresponds to the JSON schema field "encoding".
	Encoding Oauth2AuthenticationPropertiesRequestEncoding `json:"encoding,omitempty"`
}

type Oauth2AuthenticationPropertiesRequestEncoding string

const Oauth2AuthenticationPropertiesRequestEncodingApplicationJson Oauth2AuthenticationPropertiesRequestEncoding = "application/json"
const Oauth2AuthenticationPropertiesRequestEncodingApplicationXWwwFormUrlencoded Oauth2AuthenticationPropertiesRequestEncoding = "application/x-www-form-urlencoded"

var enumValues_Oauth2AuthenticationPropertiesRequestEncoding = []interface{}{
	"application/x-www-form-urlencoded",
	"application/json",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Oauth2AuthenticationPropertiesRequestEncoding) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Oauth2AuthenticationPropertiesRequestEncoding {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Oauth2AuthenticationPropertiesRequestEncoding, v)
	}
	*j = Oauth2AuthenticationPropertiesRequestEncoding(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Oauth2AuthenticationPropertiesRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Oauth2AuthenticationPropertiesRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["encoding"]; !ok || v == nil {
		plain.Encoding = "application/x-www-form-urlencoded"
	}
	*j = Oauth2AuthenticationPropertiesRequest(plain)
	return nil
}

// Represents an OAuth2 token.
type Oauth2Token struct {
	// The security token to use.
	Token string `json:"token"`

	// The type of the security token to use.
	Type string `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Oauth2Token) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["token"]; raw != nil && !ok {
		return fmt.Errorf("field token in Oauth2Token: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Oauth2Token: required")
	}
	type Plain Oauth2Token
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Oauth2Token(plain)
	return nil
}

// Configures the output of a workflow or task.
type Output struct {
	// A runtime expression, if any, used to mutate and/or filter the output of the
	// workflow or task.
	As interface{} `json:"as,omitempty"`

	// The schema used to describe and validate the output of the workflow or task.
	Schema *Schema `json:"schema,omitempty"`
}

// Represents a referenceable authentication policy.
type ReferenceableAuthenticationPolicy map[string]interface{}

// Defines a retry policy.
type RetryPolicy struct {
	// The retry duration backoff.
	Backoff RetryPolicyBackoff `json:"backoff,omitempty"`

	// The duration to wait between retry attempts.
	Delay RetryPolicyDelay `json:"delay,omitempty"`

	// A runtime expression used to determine whether or not to retry running the
	// task, in a given context.
	ExceptWhen *string `json:"exceptWhen,omitempty"`

	// The parameters, if any, that control the randomness or variability of the delay
	// between retry attempts.
	Jitter *RetryPolicyJitter `json:"jitter,omitempty"`

	// The retry limit, if any.
	Limit *RetryPolicyLimit `json:"limit,omitempty"`

	// A runtime expression, if any, used to determine whether or not to retry running
	// the task, in a given context.
	When *string `json:"when,omitempty"`
}

// The retry duration backoff.
type RetryPolicyBackoff map[string]interface{}

// The duration to wait between retry attempts.
type RetryPolicyDelay interface{}

// The parameters, if any, that control the randomness or variability of the delay
// between retry attempts.
type RetryPolicyJitter struct {
	// The minimum duration of the jitter range.
	From RetryPolicyJitterFrom `json:"from"`

	// The maximum duration of the jitter range.
	To RetryPolicyJitterTo `json:"to"`
}

// The minimum duration of the jitter range.
type RetryPolicyJitterFrom interface{}

// The maximum duration of the jitter range.
type RetryPolicyJitterTo interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RetryPolicyJitter) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in RetryPolicyJitter: required")
	}
	if _, ok := raw["to"]; raw != nil && !ok {
		return fmt.Errorf("field to in RetryPolicyJitter: required")
	}
	type Plain RetryPolicyJitter
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RetryPolicyJitter(plain)
	return nil
}

// The retry limit, if any.
type RetryPolicyLimit struct {
	// Attempt corresponds to the JSON schema field "attempt".
	Attempt *RetryPolicyLimitAttempt `json:"attempt,omitempty"`

	// The duration limit, if any, for all retry attempts.
	Duration RetryPolicyLimitDuration `json:"duration,omitempty"`
}

type RetryPolicyLimitAttempt struct {
	// The maximum amount of retry attempts, if any.
	Count *int `json:"count,omitempty"`

	// The maximum duration for each retry attempt.
	Duration RetryPolicyLimitAttemptDuration `json:"duration,omitempty"`
}

// The maximum duration for each retry attempt.
type RetryPolicyLimitAttemptDuration interface{}

// The duration limit, if any, for all retry attempts.
type RetryPolicyLimitDuration interface{}

// A runtime expression.
type RuntimeExpression string

// Represents the definition of a schema.
type Schema struct {
	// The schema's format. Defaults to 'json'. The (optional) version of the format
	// can be set using `{format}:{version}`.
	Format string `json:"format,omitempty"`
}

// Serverless Workflow DSL - Workflow Schema.
type SchemaJson struct {
	// Defines the task(s) the workflow must perform.
	Do TaskList `json:"do"`

	// Documents the workflow.
	Document SchemaJsonDocument `json:"document"`

	// Configures the workflow's input.
	Input *Input `json:"input,omitempty"`

	// Configures the workflow's output.
	Output *Output `json:"output,omitempty"`

	// Schedules the workflow.
	Schedule *SchemaJsonSchedule `json:"schedule,omitempty"`

	// Timeout corresponds to the JSON schema field "timeout".
	Timeout interface{} `json:"timeout,omitempty"`

	// Defines the workflow's reusable components.
	Use *SchemaJsonUse `json:"use,omitempty"`
}

// Documents the workflow.
type SchemaJsonDocument struct {
	// The version of the DSL used by the workflow.
	Dsl string `json:"dsl"`

	// Holds additional information about the workflow.
	Metadata SchemaJsonDocumentMetadata `json:"metadata,omitempty"`

	// The workflow's name.
	Name string `json:"name"`

	// The workflow's namespace.
	Namespace string `json:"namespace"`

	// The workflow's Markdown summary.
	Summary *string `json:"summary,omitempty"`

	// A key/value mapping of the workflow's tags, if any.
	Tags SchemaJsonDocumentTags `json:"tags,omitempty"`

	// The workflow's title.
	Title *string `json:"title,omitempty"`

	// The workflow's semantic version.
	Version string `json:"version"`
}

// Holds additional information about the workflow.
type SchemaJsonDocumentMetadata map[string]interface{}

// A key/value mapping of the workflow's tags, if any.
type SchemaJsonDocumentTags map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonDocument) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["dsl"]; raw != nil && !ok {
		return fmt.Errorf("field dsl in SchemaJsonDocument: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in SchemaJsonDocument: required")
	}
	if _, ok := raw["namespace"]; raw != nil && !ok {
		return fmt.Errorf("field namespace in SchemaJsonDocument: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in SchemaJsonDocument: required")
	}
	type Plain SchemaJsonDocument
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaJsonDocument(plain)
	return nil
}

// Schedules the workflow.
type SchemaJsonSchedule struct {
	// Specifies a delay duration that the workflow must wait before starting again
	// after it completes.
	After SchemaJsonScheduleAfter `json:"after,omitempty"`

	// Specifies the schedule using a cron expression, e.g., '0 0 * * *' for daily at
	// midnight.
	Cron *string `json:"cron,omitempty"`

	// Specifies the duration of the interval at which the workflow should be
	// executed.
	Every SchemaJsonScheduleEvery `json:"every,omitempty"`

	// Specifies the events that trigger the workflow execution.
	On EventConsumptionStrategy `json:"on,omitempty"`
}

// Specifies a delay duration that the workflow must wait before starting again
// after it completes.
type SchemaJsonScheduleAfter interface{}

// Specifies the duration of the interval at which the workflow should be executed.
type SchemaJsonScheduleEvery interface{}

// Defines the workflow's reusable components.
type SchemaJsonUse struct {
	// The workflow's reusable authentication policies.
	Authentications SchemaJsonUseAuthentications `json:"authentications,omitempty"`

	// The workflow's reusable errors.
	Errors SchemaJsonUseErrors `json:"errors,omitempty"`

	// The workflow's extensions.
	Extensions []SchemaJsonUseExtensionsElem `json:"extensions,omitempty"`

	// The workflow's reusable functions.
	Functions SchemaJsonUseFunctions `json:"functions,omitempty"`

	// The workflow's reusable retry policies.
	Retries SchemaJsonUseRetries `json:"retries,omitempty"`

	// The workflow's reusable secrets.
	Secrets []string `json:"secrets,omitempty"`

	// The workflow's reusable timeouts.
	Timeouts SchemaJsonUseTimeouts `json:"timeouts,omitempty"`
}

// The workflow's reusable authentication policies.
type SchemaJsonUseAuthentications map[string]AuthenticationPolicy

// The workflow's reusable errors.
type SchemaJsonUseErrors map[string]Error

type SchemaJsonUseExtensionsElem map[string]Extension

// The workflow's reusable functions.
type SchemaJsonUseFunctions map[string]interface{}

// The workflow's reusable retry policies.
type SchemaJsonUseRetries map[string]RetryPolicy

// The workflow's reusable timeouts.
type SchemaJsonUseTimeouts map[string]Timeout

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["do"]; raw != nil && !ok {
		return fmt.Errorf("field do in SchemaJson: required")
	}
	if _, ok := raw["document"]; raw != nil && !ok {
		return fmt.Errorf("field document in SchemaJson: required")
	}
	type Plain SchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaJson(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Schema) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Schema
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["format"]; !ok || v == nil {
		plain.Format = "json"
	}
	*j = Schema(plain)
	return nil
}

// Represents an authentication policy based on secrets.
type SecretBasedAuthenticationPolicy struct {
	// The name of the authentication policy to use.
	Use string `json:"use"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecretBasedAuthenticationPolicy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["use"]; raw != nil && !ok {
		return fmt.Errorf("field use in SecretBasedAuthenticationPolicy: required")
	}
	type Plain SecretBasedAuthenticationPolicy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Use) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "use", 1)
	}
	*j = SecretBasedAuthenticationPolicy(plain)
	return nil
}

// A discrete unit of work that contributes to achieving the overall objectives
// defined by the workflow.
type Task interface{}

// An object inherited by all tasks.
type TaskBase struct {
	// Export task output to context.
	Export *Export `json:"export,omitempty"`

	// A runtime expression, if any, used to determine whether or not the task should
	// be run.
	If *string `json:"if,omitempty"`

	// Configure the task's input.
	Input *Input `json:"input,omitempty"`

	// Holds additional information about the task.
	Metadata TaskBaseMetadata `json:"metadata,omitempty"`

	// Configure the task's output.
	Output *Output `json:"output,omitempty"`

	// The flow directive to be performed upon completion of the task.
	Then TaskBaseThen `json:"then,omitempty"`

	// Timeout corresponds to the JSON schema field "timeout".
	Timeout interface{} `json:"timeout,omitempty"`
}

// Holds additional information about the task.
type TaskBaseMetadata map[string]interface{}

// The flow directive to be performed upon completion of the task.
type TaskBaseThen interface{}

// List of named tasks to perform.
type TaskList []map[string]interface{}

// The definition of a timeout.
type Timeout struct {
	// The duration after which to timeout.
	After TimeoutAfter `json:"after"`
}

// The duration after which to timeout.
type TimeoutAfter interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Timeout) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["after"]; raw != nil && !ok {
		return fmt.Errorf("field after in Timeout: required")
	}
	type Plain Timeout
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Timeout(plain)
	return nil
}
